// Package profile handles LogFlow configuration profiles.
package profile

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// Profile represents a saved LogFlow configuration.
type Profile struct {
	Name        string            `yaml:"name,omitempty"`
	Format      string            `yaml:"format"`
	CaseID      string            `yaml:"case_id"`
	Activity    string            `yaml:"activity"`
	Timestamp   string            `yaml:"timestamp"`
	Resource    string            `yaml:"resource,omitempty"`
	Output      string            `yaml:"output,omitempty"`
	Compression string            `yaml:"compression,omitempty"`
	Delimiter   string            `yaml:"delimiter,omitempty"`
	Attributes  []string          `yaml:"attributes,omitempty"`
	Exclude     []string          `yaml:"exclude,omitempty"`
	Options     map[string]string `yaml:"options,omitempty"`
}

const (
	ProfileExtension = ".logflow.yaml"
	GlobalProfileDir = ".logflow"
)

// Load loads a profile from a file path.
func Load(path string) (*Profile, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read profile: %w", err)
	}

	var profile Profile
	if err := yaml.Unmarshal(data, &profile); err != nil {
		return nil, fmt.Errorf("failed to parse profile: %w", err)
	}

	return &profile, nil
}

// Save saves a profile to a file path.
func (p *Profile) Save(path string) error {
	data, err := yaml.Marshal(p)
	if err != nil {
		return fmt.Errorf("failed to serialize profile: %w", err)
	}

	// Add header comment
	header := "# LogFlow Configuration Profile\n# Generated by LogFlow TUI Wizard\n\n"
	content := header + string(data)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write profile: %w", err)
	}

	return nil
}

// FindProfile looks for a profile file associated with the input file.
// It checks for: input.csv.logflow.yaml, .logflow.yaml in the same directory,
// and global profiles in ~/.logflow/
func FindProfile(inputPath string) (string, error) {
	// Check for file-specific profile: input.csv.logflow.yaml
	fileProfile := inputPath + ProfileExtension
	if _, err := os.Stat(fileProfile); err == nil {
		return fileProfile, nil
	}

	// Check for directory profile: .logflow.yaml
	dir := filepath.Dir(inputPath)
	dirProfile := filepath.Join(dir, ProfileExtension)
	if _, err := os.Stat(dirProfile); err == nil {
		return dirProfile, nil
	}

	// Check global profiles
	homeDir, err := os.UserHomeDir()
	if err == nil {
		globalDir := filepath.Join(homeDir, GlobalProfileDir)
		baseName := strings.TrimSuffix(filepath.Base(inputPath), filepath.Ext(inputPath))
		globalProfile := filepath.Join(globalDir, baseName+ProfileExtension)
		if _, err := os.Stat(globalProfile); err == nil {
			return globalProfile, nil
		}
	}

	return "", fmt.Errorf("no profile found for %s", inputPath)
}

// ProfilePathForInput returns the recommended profile path for an input file.
func ProfilePathForInput(inputPath string) string {
	return inputPath + ProfileExtension
}

// GlobalProfilePath returns the global profile path for a profile name.
func GlobalProfilePath(name string) (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("failed to get home directory: %w", err)
	}

	globalDir := filepath.Join(homeDir, GlobalProfileDir)
	if err := os.MkdirAll(globalDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create global profile directory: %w", err)
	}

	return filepath.Join(globalDir, name+ProfileExtension), nil
}

// ListGlobalProfiles returns all global profiles.
func ListGlobalProfiles() ([]string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("failed to get home directory: %w", err)
	}

	globalDir := filepath.Join(homeDir, GlobalProfileDir)
	entries, err := os.ReadDir(globalDir)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to read profile directory: %w", err)
	}

	var profiles []string
	for _, entry := range entries {
		if strings.HasSuffix(entry.Name(), ProfileExtension) {
			name := strings.TrimSuffix(entry.Name(), ProfileExtension)
			profiles = append(profiles, name)
		}
	}

	return profiles, nil
}
